'use strict'

const fsp = require('node:fs/promises')
const ospath = require('node:path')
const parseCommand = require('./parse-command')
const { execFile, spawn } = require('node:child_process')

const ENV_NAME_RX = /\$(\w+)/g
const invariably = { true: () => true, false: () => false, void: () => undefined }
const WIN = process.platform === 'win32'
const escapeForCmd = WIN ? require('./escape-for-cmd') : undefined

async function runCommand (cmd, args, opts = {}) {
  if (!Array.isArray(args) && (opts = args == null || args.constructor !== Object ? {} : args)) args = undefined
  const shell = !!opts.shell
  let cmdv = []
  if (cmd) cmdv = (opts.parse ?? args == null) ? parseCommand(String(cmd), { preserveQuotes: shell }) : [cmd]
  let cmd0 = cmdv[0]
  if (!cmd0) throw new TypeError('Command not specified')
  if (args) cmdv.push(...args)
  const { cache = {}, encoding = 'buffer', local, parse: _parse, stdin, stdout, stderr, ...spawnOpts } = opts
  if (WIN) {
    if (~cmd0.indexOf('/')) cmdv[0] = cmd0 = cmd0.replace(/[/]/g, ospath.sep)
    if (shell) {
      cmdv = cmdv.map((it) => (~it.indexOf('$') ? it.replace(ENV_NAME_RX, '%$1%') : it))
    } else {
      const cwd = opts.cwd || ''
      const bare = !~cmd0.indexOf(ospath.sep)
      let extname = ospath.extname(cmd0)
      if (extname) {
        if (bare && local) cmdv[0] = '.' + ospath.sep + cmd0
      } else if (bare && !local) {
        const absCmd0 = await whereLocal(ospath.resolve(cwd, cmd0)).then((res) => res ?? where(cmd0, cache.where))
        cmdv[0] += extname = ospath.extname(absCmd0)
      } else {
        const absCmd0 = !bare && ospath.isAbsolute(cmd0) ? cmd0 : ospath.resolve(cwd, cmd0)
        extname = ospath.extname((await whereLocal(absCmd0)) ?? '')
        cmdv[0] = (bare ? (cmd0 = '.' + ospath.sep + cmd0) : cmd0) + extname // bare implies local
        if (!extname) throw new Error(`Command not found: ${cmd0}`)
      }
      if ((extname === '.bat' || extname === '.cmd') && (spawnOpts.shell = true)) cmdv = cmdv.map(escapeForCmd)
    }
    Object.assign(spawnOpts, { windowsHide: true, windowsVerbatimArguments: !!spawnOpts.shell })
  } else if (local && !~cmd0.indexOf('/')) {
    cmdv[0] = './' + cmd0
  }
  return spawnCommand(cmdv, spawnOpts, { stdin, stdout, stderr, encoding })
}

function spawnCommand (cmdv, opts, stdio) {
  return new Promise((resolve, reject) => {
    try {
      const cmd0 = cmdv[0]
      const buffers = { stdout: [], stderr: [] }
      opts.stdio = toStdioOption(stdio, buffers)
      const p = opts.shell ? spawn(cmdv.join(' '), opts) : spawn(cmd0, cmdv.slice(1), opts)
      p.on('close', (status, signal) => {
        const stdout = stdio.stdout === 'buffer' ? encodeBufferArray(buffers.stdout, stdio.encoding) : null
        const stderr = stdio.stderr === 'buffer' ? encodeBufferArray(buffers.stderr, stdio.encoding) : null
        if (!status) {
          const result = { status, signal, stdout, stderr }
          if (stdout == null) return resolve(result)
          if (typeof stdout === 'string') return resolve(Object.assign(new String(stdout), result))
          Object.defineProperty(Object.assign(stdout, result), 'stdout', {
            get () {
              return this.slice()
            },
            set (value) {
              Object.defineProperty(this, 'stdout', { value })
            },
          })
          return resolve(stdout)
        }
        const err = new Error(`Command failed with exit status ${status}: ${p.spawnargs.join(' ')}`)
        Object.assign(err, { exitStatus: status, spawnargs: p.spawnargs, stdout, stderr })
        if (stdio.stderr === 'print') {
          err.message += '\n(refer to terminal output for more detail)'
        } else if (stdio.stderr === 'buffer') {
          err.message += `\n${encodeBufferArray(buffers.stderr, 'utf8').replace(/\r(?=\n)/g, '')}`.trimEnd()
        }
        if (!(status === 127 && opts.shell && !WIN)) return reject(err)
        execFile('which ' + cmd0, { cwd: opts.cwd, env: opts.env, shell: true }, (whichErr) => {
          reject(whichErr ? new Error(`Command not found: ${cmd0}`) : err)
        })
      })
      p.on('error', (err) => reject(err.code === 'ENOENT' ? new Error(`Command not found: ${cmd0}`) : err))
      if (p.stdout) p.stdout.on('data', (data) => buffers.stdout.push(data))
      if (p.stderr) p.stderr.on('data', (data) => buffers.stderr.push(data))
      if (p.stdin) {
        try {
          p.stdin.on('error', invariably.void)
          if (stdio.stdin.pipe) {
            stdio.stdin
              .on('error', (err) => {
                p.off('close', p.listeners('close')[0]).kill(WIN ? undefined : 'SIGHUP')
                reject(err)
              })
              .pipe(p.stdin)
          } else {
            p.stdin.end(String(stdio.stdin))
          }
        } catch (stdinErr) {
          p.stdin.end()
          reject(stdinErr)
        }
      }
    } catch (err) {
      reject(err)
    }
  })
}

function toStdioOption (stdio, buffers) {
  return ['stdin', 'stdout', 'stderr'].map((streamName) => {
    if (streamName === 'stdin') return (stdio[streamName] ?? false) === false ? 'ignore' : 'pipe'
    switch (stdio[streamName]) {
      case undefined:
        return (stdio[streamName] = 'buffer') && 'pipe'
      case 'print':
        return process[streamName]
      case 'buffer':
        return 'pipe'
      case 'stdout':
        if (streamName !== 'stderr') break
        if (stdio.stdout === 'print') return (stdio.stderr = 'ignore') && process.stdout
        if (stdio.stdout === 'buffer') return (stdio.stderr = 'ignore') && (buffers.stderr = buffers.stdout) && 'pipe'
    }
    return (stdio[streamName] = 'ignore')
  })
}

function encodeBufferArray (data, encoding) {
  return encoding === 'buffer' ? Buffer.concat(data) : Buffer.concat(data).toString(encoding)
}

function where (cmd0, cache = {}) {
  if (cmd0 in cache) return cache[cmd0]
  return new Promise((resolve, reject) => {
    execFile('where', [cmd0 + '.???'], { cwd: process.env.SystemRoot, windowsHide: true }, (err, results) => {
      if (err) return reject(new Error(`Command not found: ${cmd0}`))
      results = results.trimEnd().split('\r\n')
      const exts = results.reduce((accum, it) => Object.assign(accum, { [ospath.extname(it).slice(1)]: it }), {})
      const resolved = exts.com || exts.exe || exts.bat || exts.cmd
      resolved ? resolve(resolved) : reject(new Error(`Command not found: ${cmd0}`))
    })
  })
}

async function whereLocal (absCmd0) {
  for (const pathext of ['.com', '.exe', '.bat', '.cmd']) {
    if (await fsp.access(absCmd0 + pathext).then(invariably.true, invariably.false)) return absCmd0 + pathext
  }
}

module.exports = runCommand
